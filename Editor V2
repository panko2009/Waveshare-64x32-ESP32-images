import tkinter as tk
from tkinter import colorchooser, simpledialog
import time

WIDTH = 64
HEIGHT = 32
CELL_SIZE = 15

class LEDDesigner:
    def __init__(self, root):
        self.root = root
        self.root.title("LED Animation Designer (64x32)")
        self.canvas = tk.Canvas(root, width=WIDTH*CELL_SIZE, height=(HEIGHT+1)*CELL_SIZE, bg="black")
        self.canvas.pack()

        self.frames = []
        self.current_frame = [["#000000" for _ in range(WIDTH)] for _ in range(HEIGHT)]
        self.frames.append([row[:] for row in self.current_frame])

        self.selected_color = "#FFFFFF"
        self.history = []
        self.future = []
        self.frame_duration = 500

        # tools / brush
        self.brush_size = 1
        self.tool = "brush"  # "brush" or "lasso"

        # lasso state
        self.is_selecting = False
        self.lasso_start = None
        self.lasso_rect = None
        self.lasso_buffer = None
        self.lasso_width = 0
        self.lasso_height = 0
        self.lasso_active = False  # selection ready to place

        # mouse bindings
        self.canvas.bind("<Button-1>", self.on_mouse_down)
        self.canvas.bind("<B1-Motion>", self.on_mouse_drag)
        self.canvas.bind("<ButtonRelease-1>", self.on_mouse_up)
        self.root.bind("<Control-z>", self.ctrl_z)

        # controls
        control_frame = tk.Frame(root)
        control_frame.pack(pady=5)

        self.color_entry = tk.Entry(control_frame, width=10)
        self.color_entry.insert(0, self.selected_color)
        self.color_entry.pack(side=tk.LEFT, padx=2)

        tk.Button(control_frame, text="Pick Color", command=self.pick_color).pack(side=tk.LEFT, padx=2)
        tk.Button(control_frame, text="Undo", command=self.undo).pack(side=tk.LEFT, padx=2)
        tk.Button(control_frame, text="Redo", command=self.redo).pack(side=tk.LEFT, padx=2)
        tk.Button(control_frame, text="Eraser", command=self.activate_eraser).pack(side=tk.LEFT, padx=2)

        # brush size buttons
        tk.Label(control_frame, text="Brush:").pack(side=tk.LEFT, padx=2)
        tk.Button(control_frame, text="S", command=lambda: self.set_brush_size(1)).pack(side=tk.LEFT, padx=1)
        tk.Button(control_frame, text="M", command=lambda: self.set_brush_size(3)).pack(side=tk.LEFT, padx=1)
        tk.Button(control_frame, text="L", command=lambda: self.set_brush_size(5)).pack(side=tk.LEFT, padx=1)

        # lasso button
        tk.Button(control_frame, text="Lasso", command=self.activate_lasso).pack(side=tk.LEFT, padx=2)

        tk.Button(control_frame, text="Add Frame", command=self.add_frame).pack(side=tk.LEFT, padx=2)
        tk.Button(control_frame, text="Preview", command=self.preview_animation).pack(side=tk.LEFT, padx=2)
        tk.Button(control_frame, text="Export Code", command=self.export_code).pack(side=tk.LEFT, padx=2)
        tk.Button(control_frame, text="Import Code", command=self.open_import_window).pack(side=tk.LEFT, padx=2)

        self.rects = [[None for _ in range(WIDTH)] for _ in range(HEIGHT)]

        # top ruler row
        for x in range(WIDTH):
            x1 = x * CELL_SIZE
            color = self.get_ruler_color(x)
            self.canvas.create_rectangle(x1, 0, x1 + CELL_SIZE, CELL_SIZE, fill=color, outline=color)

        # pixel grid
        for y in range(HEIGHT):
            for x in range(WIDTH):
                x1, y1 = x * CELL_SIZE, (y + 1) * CELL_SIZE
                rect = self.canvas.create_rectangle(
                    x1, y1, x1 + CELL_SIZE, y1 + CELL_SIZE,
                    fill="black", outline="#222"
                )
                self.rects[y][x] = rect

    # ---------- helpers ----------

    def get_ruler_color(self, x):
        if x < 2 or x >= WIDTH - 2:
            return "red"
        segment = x - 2
        block_index = segment // 4
        return "green" if block_index % 2 == 0 else "red"

    def set_brush_size(self, size):
        self.brush_size = size
        self.tool = "brush"
        print(f"Brush size set to {size}x{size}")

    def activate_lasso(self):
        self.tool = "lasso"
        self.is_selecting = False
        self.lasso_active = False
        self.lasso_buffer = None
        if self.lasso_rect is not None:
            self.canvas.delete(self.lasso_rect)
            self.lasso_rect = None
        print("Lasso tool active")

    def grid_coords_from_event(self, event):
        x = event.x // CELL_SIZE
        y = (event.y - CELL_SIZE) // CELL_SIZE
        return x, y

    # ---------- mouse handlers ----------

    def on_mouse_down(self, event):
        if self.tool == "brush":
            self.draw_with_brush(event)
        elif self.tool == "lasso":
            if self.lasso_active and self.lasso_buffer is not None:
                # place selection at new location
                self.place_lasso(event)
            else:
                # start selection
                self.start_lasso(event)

    def on_mouse_drag(self, event):
        if self.tool == "brush":
            self.draw_with_brush(event)
        elif self.tool == "lasso" and self.is_selecting:
            self.update_lasso_rect(event)

    def on_mouse_up(self, event):
        if self.tool == "lasso" and self.is_selecting:
            self.finish_lasso_selection(event)

    # ---------- brush drawing ----------

    def draw_with_brush(self, event):
        x_center, y_center = self.grid_coords_from_event(event)
        half = self.brush_size // 2

        for dy in range(-half, half + 1):
            for dx in range(-half, half + 1):
                x = x_center + dx
                y = y_center + dy

                if 0 <= x < WIDTH and 0 <= y < HEIGHT:
                    prev_color = self.current_frame[y][x]
                    new_color = self.selected_color
                    if prev_color != new_color:
                        self.history.append((x, y, prev_color))
                        self.current_frame[y][x] = new_color
                        self.canvas.itemconfig(self.rects[y][x], fill=new_color)
                        self.future.clear()
                        self.frames[-1][y][x] = new_color

    # keep for compatibility, but route to brush logic
    def paint_pixel(self, event):
        self.draw_with_brush(event)

    def release_mouse(self, event):
        pass

    # ---------- lasso selection / move ----------

    def start_lasso(self, event):
        x, y = self.grid_coords_from_event(event)
        if not (0 <= x < WIDTH and 0 <= y < HEIGHT):
            return
        self.is_selecting = True
        self.lasso_start = (x, y)
        if self.lasso_rect is not None:
            self.canvas.delete(self.lasso_rect)
            self.lasso_rect = None

    def update_lasso_rect(self, event):
        if not self.is_selecting or self.lasso_start is None:
            return
        x_end, y_end = self.grid_coords_from_event(event)
        x0, y0 = self.lasso_start

        x_min, x_max = sorted((x0, x_end))
        y_min, y_max = sorted((y0, y_end))

        # clamp to grid
        x_min = max(0, min(WIDTH - 1, x_min))
        x_max = max(0, min(WIDTH - 1, x_max))
        y_min = max(0, min(HEIGHT - 1, y_min))
        y_max = max(0, min(HEIGHT - 1, y_max))

        x1 = x_min * CELL_SIZE
        y1 = (y_min + 1) * CELL_SIZE
        x2 = (x_max + 1) * CELL_SIZE + CELL_SIZE
        y2 = (y_max + 1) * CELL_SIZE + CELL_SIZE

        if self.lasso_rect is None:
            self.lasso_rect = self.canvas.create_rectangle(
                x1, y1, x2, y2,
                outline="yellow", width=2
            )
        else:
            self.canvas.coords(self.lasso_rect, x1, y1, x2, y2)

    def finish_lasso_selection(self, event):
        if not self.is_selecting or self.lasso_start is None:
            return

        x_end, y_end = self.grid_coords_from_event(event)
        x0, y0 = self.lasso_start
        self.is_selecting = False

        x_min, x_max = sorted((x0, x_end))
        y_min, y_max = sorted((y0, y_end))

        # clamp
        x_min = max(0, min(WIDTH - 1, x_min))
        x_max = max(0, min(WIDTH - 1, x_max))
        y_min = max(0, min(HEIGHT - 1, y_min))
        y_max = max(0, min(HEIGHT - 1, y_max))

        if x_min > x_max or y_min > y_max:
            return

        self.lasso_width = x_max - x_min + 1
        self.lasso_height = y_max - y_min + 1

        # copy selected pixels into buffer
        self.lasso_buffer = []
        for yy in range(y_min, y_max + 1):
            row = []
            for xx in range(x_min, x_max + 1):
                row.append(self.current_frame[yy][xx])
            self.lasso_buffer.append(row)

        # clear original area (cut)
        for yy in range(y_min, y_max + 1):
            for xx in range(x_min, x_max + 1):
                prev_color = self.current_frame[yy][xx]
                if prev_color != "#000000":
                    self.history.append((xx, yy, prev_color))
                    self.current_frame[yy][xx] = "#000000"
                    self.canvas.itemconfig(self.rects[yy][xx], fill="#000000")
                    self.frames[-1][yy][xx] = "#000000"

        self.future.clear()
        self.lasso_active = True
        print("Lasso selection captured; click somewhere to place it.")

    def place_lasso(self, event):
        if not self.lasso_active or self.lasso_buffer is None:
            return

        target_x, target_y = self.grid_coords_from_event(event)
        if not (0 <= target_x < WIDTH and 0 <= target_y < HEIGHT):
            return

        for dy in range(self.lasso_height):
            for dx in range(self.lasso_width):
                x = target_x + dx
                y = target_y + dy
                if 0 <= x < WIDTH and 0 <= y < HEIGHT:
                    color = self.lasso_buffer[dy][dx]
                    prev_color = self.current_frame[y][x]
                    if prev_color != color:
                        self.history.append((x, y, prev_color))
                        self.current_frame[y][x] = color
                        self.canvas.itemconfig(self.rects[y][x], fill=color)
                        self.frames[-1][y][x] = color

        self.future.clear()
        self.lasso_active = False
        self.lasso_buffer = None
        if self.lasso_rect is not None:
            self.canvas.delete(self.lasso_rect)
            self.lasso_rect = None
        # stay in lasso mode so you can select again
        print("Lasso selection placed.")

    # ---------- color / eraser / undo-redo ----------

    def set_color_from_entry(self):
        color = self.color_entry.get().strip()
        if color.startswith('#') and len(color) == 7:
            self.selected_color = color.upper()
        else:
            print("Invalid hex color. Use format #RRGGBB")

    def pick_color(self):
        color = colorchooser.askcolor(title="Choose color", initialcolor=self.selected_color)[1]
        if color:
            self.selected_color = color
            self.color_entry.delete(0, tk.END)
            self.color_entry.insert(0, color)

    def activate_eraser(self):
        self.selected_color = "#000000"
        self.color_entry.delete(0, tk.END)
        self.color_entry.insert(0, "#000000")

    def undo(self):
        if self.history:
            x, y, prev_color = self.history.pop()
            current_color = self.current_frame[y][x]
            self.current_frame[y][x] = prev_color
            self.canvas.itemconfig(self.rects[y][x], fill=prev_color)
            self.future.append((x, y, current_color))
            self.frames[-1][y][x] = prev_color

    def ctrl_z(self, event):
        self.undo()

    def redo(self):
        if self.future:
            x, y, redo_color = self.future.pop()
            prev_color = self.current_frame[y][x]
            self.current_frame[y][x] = redo_color
            self.canvas.itemconfig(self.rects[y][x], fill=redo_color)
            self.history.append((x, y, prev_color))
            self.frames[-1][y][x] = redo_color

    # ---------- frames / preview ----------

    def add_frame(self):
        self.frames.append([row[:] for row in self.current_frame])
        self.history.clear()
        self.future.clear()
        print(f"Added frame {len(self.frames)}")

    def preview_animation(self):
        try:
            duration = int(simpledialog.askstring("Frame Duration (ms)", "Enter duration per frame in milliseconds:"))
            if duration <= 0:
                raise ValueError
            self.frame_duration = duration
        except:
            print("Invalid duration. Using default 500ms.")
            self.frame_duration = 500

        for frame in self.frames:
            for y in range(HEIGHT):
                for x in range(WIDTH):
                    self.canvas.itemconfig(self.rects[y][x], fill=frame[y][x])
            self.root.update()
            time.sleep(self.frame_duration / 1000.0)

    # ---------- export / import ----------

    def export_code(self):
        result = "\n// === COPY THIS INTO YOUR ESP IDE ===\n"
        for y in range(HEIGHT):
            for x in range(WIDTH):
                color = self.current_frame[y][x]
                if color != "#000000":
                    r = int(color[1:3], 16)
                    b = int(color[3:5], 16)
                    g = int(color[5:7], 16)
                    result += f"  matrix->drawPixelRGB888({x}, {y}, {r}, {g}, {b});\n"
        

        preview_window = tk.Toplevel(self.root)
        preview_window.title("Exported Code")
        text_box = tk.Text(preview_window, wrap=tk.NONE)
        text_box.insert(tk.END, result)
        text_box.pack(expand=True, fill="both")

    def open_import_window(self):
        win = tk.Toplevel(self.root)
        win.title("Import Code")

        text_box = tk.Text(win, wrap=tk.NONE, width=80, height=25)
        text_box.pack(expand=True, fill="both")

        def do_import():
            content = text_box.get("1.0", tk.END)
            self.import_from_string(content)

        tk.Button(win, text="Load", command=do_import).pack(pady=5)

    def import_from_string(self, content: str):
        # clear current frame
        for y in range(HEIGHT):
            for x in range(WIDTH):
                prev_color = self.current_frame[y][x]
                if prev_color != "#000000":
                    self.history.append((x, y, prev_color))
                self.current_frame[y][x] = "#000000"
                self.canvas.itemconfig(self.rects[y][x], fill="#000000")
                self.frames[-1][y][x] = "#000000"

        self.future.clear()

        for line in content.splitlines():
            if "drawPixelRGB888" in line:
                try:
                    start = line.index("(")
                    end = line.index(")", start)
                    inside = line[start+1:end]
                    parts = [p.strip() for p in inside.split(",")]
                    if len(parts) != 5:
                        continue
                    x = int(parts[0])
                    y = int(parts[1])
                    r = int(parts[2])
                    b = int(parts[3])
                    g = int(parts[4])

                    if 0 <= x < WIDTH and 0 <= y < HEIGHT:
                        color = "#{:02X}{:02X}{:02X}".format(r, g, b)
                        prev_color = self.current_frame[y][x]
                        if prev_color != color:
                            self.history.append((x, y, prev_color))
                            self.current_frame[y][x] = color
                            self.canvas.itemconfig(self.rects[y][x], fill=color)
                            self.frames[-1][y][x] = color
                except Exception:
                    continue

        print("Import complete.")

if __name__ == "__main__":
    root = tk.Tk()
    app = LEDDesigner(root)
    root.mainloop()
